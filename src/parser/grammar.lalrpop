use ast::{Program, Stmt, StmtKind};
use ast::{BinOpKind, UnOpKind};
use ast::{Expr, ExprKind, Literal};
use ast::{DataType, DataTypeKind, Field};
use parser::{lexer, span, token, Span};

grammar;

Box<T>: Box<T> = T => Box::new(<>);

Binary<Op, Next>: Expr = {
    <lo:@L> <lhs:Box<Binary<Op, Next>>> <o:Op> <rhs:Box<Next>> <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Binary(o, lhs, rhs)),
    Next
};

List<T>: Vec<T> = <a:(<T> ",")*> <b:T>
    => {
        let mut a = a;
        a.push(b);
        a
    };

OptList<T>: Vec<T> = List<T>?
    => <>.unwrap_or(Vec::new());

pub Program: Program = <lo:@L> <v:Stmt*> <hi:@R>
    => Program::new(Span(lo, hi), v);

Stmt: Stmt = {
    CompoundStmt,
    IfStmt,
    WhileStmt,
    FnDeclStmt,
    StructDeclStmt,
    ShortFnDeclStmt,
    ReturnStmt,
    <lo:@L> <e:Box<Expr>> ";" <hi:@R>
        => Stmt::new(Span(lo, hi), StmtKind::Expr(e))
};

CompoundStmt: Stmt = <lo:@L> "{" <v:Stmt*> "}" <hi:@R>
    => Stmt::new(Span(lo, hi), StmtKind::Compound(v));

WhileStmt: Stmt = <lo:@L> "while" <cond:Box<Expr>> <csq:Box<CompoundStmt>> <hi:@R>
    => Stmt::new(Span(lo, hi), StmtKind::While(cond, csq));

IfStmt: Stmt = <lo:@L> "if" <cond:Box<Expr>> <csq:Box<CompoundStmt>> <alt:("else" <Box<IfOrBlock>>)?> <hi:@R>
    => Stmt::new(Span(lo, hi), StmtKind::If(cond, csq, alt));

IfOrBlock = {
    CompoundStmt,
    IfStmt
};

ReturnStmt: Stmt = <lo:@L> "return" <e:Box<Expr>> ";" <hi:@L>
    => Stmt::new(Span(lo, hi), StmtKind::Return(e));

FnDeclStmt: Stmt = <lo:@L> "func" <name:Ident> "(" <params:OptList<FieldList>> ")" <rlo:@L>
                   <rtype:("->" <Box<DataType>>)?> <rhi:@R> <body:Box<CompoundStmt>> <hi:@R>
    => {
        let params = params.into_iter().flat_map(|x| x.into_iter()).collect();
        let rtype = rtype.unwrap_or(Box::new(DataType::new(Span(rlo, rhi), DataTypeKind::Void)));
        Stmt::new(Span(lo, hi), StmtKind::FuncDecl(name, rtype, params, body))
    };

ShortFnDeclStmt: Stmt = <lo:@L> "func" <name:Ident> "(" <params:OptList<FieldList>> ")" <rlo:@L>
                        <rtype:("->" <Box<DataType>>)?> <rhi:@R> <blo:@L> "=" <body:Box<Expr>> ";" <hi:@R>
    => {
        let params = params.into_iter().flat_map(|x| x.into_iter()).collect();
        let rtype = rtype.unwrap_or(Box::new(DataType::new(Span(rlo, rhi), DataTypeKind::Void)));
        let rstmt = Box::new(Stmt::new(Span(blo, hi.clone()), StmtKind::Return(body)));
        Stmt::new(Span(lo, hi), StmtKind::FuncDecl(name, rtype, params, rstmt))
    };

Field: Field = <i:Ident> ":" <t:DataType>
    => Field::new(i, t);

FieldList: Vec<Field> = <is:List<Ident>> ":" <t:DataType>
    => is.into_iter().map(|i| Field::new(i, t.clone())).collect();

StructDeclStmt: Stmt = <lo:@L> "struct" <name:Ident> "{" <fields:(<FieldList> ";")+> "}" <hi:@R>
    => Stmt::new(Span(lo, hi), StmtKind::StructDecl(name, fields.into_iter().flat_map(|x| x.into_iter()).collect()));

Expr = Declaration;

Declaration: Expr = {
    <lo:@L> <field:Field> <val:("=" <Box<Declaration>>)?> <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Decl(field, val)),
    Assignment
};

Assignment = Binary<AssignmentKind, Cast>;
AssignmentKind: BinOpKind = "="
    => BinOpKind::Assign;

Cast = {
    <lo:@L> <lhs:Box<Cast>> "as" <dt:DataType> <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Cast(lhs, dt)),
    Sum
};

Sum = Binary<SumKind, Factor>;
SumKind: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub
};

Factor = Binary<FactorKind, Unary>;
FactorKind: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
    "%" => BinOpKind::Mod,
};

Unary = {
    <lo:@L> <o:UnaryKind> <rhs:Box<Unary>> <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Unary(o, rhs)),
    PostfixExpr
};

UnaryKind: UnOpKind = {
    "-" => UnOpKind::Neg,
    "~" => UnOpKind::Compl,
    "!" => UnOpKind::Not,
    "*" => UnOpKind::Deref,
    "&" => UnOpKind::Ref
};

PostfixExpr: Expr = {
    <lo:@L> <lhs:Box<PostfixExpr>> "(" <params:OptList<Expr>> ")" <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Call(lhs, params)),
    <lo:@L> <lhs:Box<PostfixExpr>> "[" <rhs:Box<Expr>> "]" <hi:@R>
        => Expr::unchecked(Span(lo, hi), ExprKind::Subscript(lhs, rhs)),
    Atom
};

Atom: Expr = {
    <lo:@L> <l:Literal> <hi:@R> => Expr::unchecked(Span(lo, hi), ExprKind::Literal(l)),
    "(" <Expr> ")",
    <lo:@L> <i:Ident> <hi:@R> => Expr::unchecked(Span(lo, hi), ExprKind::Name(i))
};

Literal: Literal = {
    Integer => Literal::Integer(<>)
};

DataType: DataType = {
    <lo:@L> "func" "(" <params:OptList<DataType>> ")" <rlo:@L> <rtype:("->" <Box<DataType>>)?> <hi:@R>
        => {
            let rtype = rtype.unwrap_or(Box::new(DataType::new(Span(rlo, hi.clone()), DataTypeKind::Void)));
            DataType::new(Span(lo, hi), DataTypeKind::Func(rtype, params))
        },
    DataTypePtr
};

DataTypePtr: DataType = {
    <lo:@L> <ptr:Box<DataTypePtr>> <hi:@R> "*" => DataType::new(Span(lo, hi), DataTypeKind::Ptr(ptr)),
    DataTypeAtom
};

DataTypeAtom: DataType = {
    <lo:@L> "u8" <hi:@L> => DataType::new(Span(lo, hi), DataTypeKind::U8),
    <lo:@L> "void" <hi:@R> => DataType::new(Span(lo, hi), DataTypeKind::Void),
    <lo:@L> <i:Ident> <hi:@R> => DataType::new(Span(lo, hi), DataTypeKind::Alias(i)),
    <lo:@L> "(" <ptr:Box<DataType>> ")" <hi:@R> => DataType::new(Span(lo, hi), DataTypeKind::Paren(ptr)),
};

Integer: i64 = "INTEGER"
    => match <> {
        token::Token::Integer(s) => s.parse::<i64>().unwrap(),
        _ => unreachable!()
    };

Ident: String = "IDENT"
    => match <> {
        token::Token::Ident(s) => s,
        _ => unreachable!()
    };


extern {
    type Location = span::Location;
    type Error = lexer::UnexpectedCharError;

    enum token::Token {
        "," => token::Token::Comma,
        ";" => token::Token::Semi,
        "{" => token::Token::BraceOpen,
        "}" => token::Token::BraceClose,
        "(" => token::Token::ParenOpen,
        ")" => token::Token::ParenClose,
        "[" => token::Token::BracketOpen,
        "]" => token::Token::BracketClose,
        "=" => token::Token::Equals,
        ":" => token::Token::Colon,
        "+" => token::Token::Plus,
        "-" => token::Token::Minus,
        "*" => token::Token::Star,
        "/" => token::Token::Slash,
        "%" => token::Token::Percent,
        "~" => token::Token::Tilde,
        "!" => token::Token::Exclamation,
        "&" => token::Token::Ampersand,
        "->" => token::Token::Arrow,
        "while" => token::Token::While,
        "if" => token::Token::If,
        "else" => token::Token::Else,
        "return" => token::Token::Return,
        "func" => token::Token::Func,
        "struct" => token::Token::Struct,
        "as" => token::Token::As,
        "u8" => token::Token::U8,
        "void" => token::Token::Void,
        "INTEGER" => token::Token::Integer(_),
        "IDENT" => token::Token::Ident(_),
    }
}