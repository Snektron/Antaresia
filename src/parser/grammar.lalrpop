use ast::{Program, Stmt, StmtKind};
use ast::{BinOpKind, UnOpKind};
use ast::{Expr, ExprKind, Literal};
use datatype::{DataType, Field};
use parser::{lexer, location, token};

grammar;

Box<T>: Box<T> = T => Box::new(<>);

Binary<Op, Next>: Expr = {
    <lhs:Box<Binary<Op, Next>>> <o:Op> <rhs:Box<Next>>
        => Expr::new(ExprKind::Binary(o, lhs, rhs)),
    Next
};

List<T>: Vec<T> = <a:(<T> ",")*> <b:T>
    => {
        let mut a = a;
        a.push(b);
        a
    };

OptList<T>: Vec<T> = List<T>?
    => <>.unwrap_or(Vec::new());

pub Program: Program = Stmt*
    => Program::new(<>);

Stmt: Stmt = {
    CompoundStmt,
    IfStmt,
    WhileStmt,
    FnDeclStmt,
    StructDeclStmt,
    <ShortFnDeclStmt> ";",
    <ReturnStmt> ";",
    <Box<Expr>> ";"
        => Stmt::new(StmtKind::Expr(<>))
};

CompoundStmt: Stmt = "{" <Stmt*> "}"
    => Stmt::new(StmtKind::Compound(<>));

WhileStmt: Stmt = "while" <cond:Box<Expr>> <csq:Box<CompoundStmt>>
    => Stmt::new(StmtKind::While(cond, csq));

IfStmt: Stmt = "if" <cond:Box<Expr>> <csq:Box<CompoundStmt>> <alt:("else" <Box<IfOrBlock>>)?>
    => Stmt::new(StmtKind::If(cond, csq, alt));

IfOrBlock = {
    CompoundStmt,
    IfStmt
};

ReturnStmt: Stmt = "return" <Box<Expr>>
    => Stmt::new(StmtKind::Return(<>));

FnDeclStmt: Stmt = "func" <name:Ident> "(" <params:OptList<FieldList>> ")" <rt:("->" <DataType>)?> <body:Box<CompoundStmt>>
    => {
        let params = params.into_iter().flat_map(|x| x.into_iter()).collect();
        Stmt::new(StmtKind::FuncDecl(name, rt.unwrap_or(DataType::Void), params, body))
    };

ShortFnDeclStmt: Stmt = "func" <name:Ident> "(" <params:OptList<FieldList>> ")" <rt:("->" <DataType>)?> "=" <body:Box<Expr>>
    => {
        let params = params.into_iter().flat_map(|x| x.into_iter()).collect();
        Stmt::new(StmtKind::FuncDecl(name, rt.unwrap_or(DataType::Void), params, Box::new(Stmt::new(StmtKind::Return(body)))))
    };

Field: Field = <i:Ident> ":" <t:DataType>
    => Field(t, i);

FieldList: Vec<Field> = <is:List<Ident>> ":" <t:DataType>
    => is.into_iter().map(|i| Field(t.clone(), i)).collect();

StructDeclStmt: Stmt = "struct" <name:Ident> "{" <fields:(<FieldList> ";")+> "}"
    => Stmt::new(StmtKind::StructDecl(name, fields.into_iter().flat_map(|x| x.into_iter()).collect()));

Expr = Declaration;

Declaration: Expr = {
    <field:Field> <val:("=" <Box<Declaration>>)?>
        => Expr::new(ExprKind::Decl(field, val)),
    Assignment
};

Assignment = Binary<AssignmentKind, Cast>;
AssignmentKind: BinOpKind = "="
    => BinOpKind::Assign;

Cast = {
    <lhs:Box<Cast>> "as" <dt:DataType>
        => Expr::new(ExprKind::Cast(lhs, dt)),
    Sum
};

Sum = Binary<SumKind, Factor>;
SumKind: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub
};

Factor = Binary<FactorKind, Unary>;
FactorKind: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
    "%" => BinOpKind::Mod,
};

Unary = {
    <o:UnaryKind> <rhs:Box<Unary>>
        => Expr::new(ExprKind::Unary(o, rhs)),
    PostfixExpr
};

UnaryKind: UnOpKind = {
    "-" => UnOpKind::Neg,
    "~" => UnOpKind::Compl,
    "!" => UnOpKind::Not,
    "*" => UnOpKind::Deref,
    "&" => UnOpKind::Ref
};

PostfixExpr: Expr = {
    <lhs:Box<PostfixExpr>> "(" <params:OptList<Expr>> ")"
        => Expr::new(ExprKind::Call(lhs, params)),
    <lhs:Box<PostfixExpr>> "[" <rhs:Box<Expr>> "]"
        => Expr::new(ExprKind::Subscript(lhs, rhs)),
    Atom
};

Atom: Expr = {
    Literal => Expr::new(ExprKind::Literal(<>)),
    "(" <Expr> ")",
    Ident => Expr::new(ExprKind::Name(<>))
};

Literal: Literal = {
    Integer => Literal::Integer(<>)
};

DataType: DataType = {
    "u8" => DataType::U8,
    "void" => DataType::Void,
    <Box<DataType>> "*" => DataType::Ptr(<>),
    Ident => DataType::Alias(<>)
};

Integer: i64 = "INTEGER"
    => match <> {
        token::Token::Integer(s) => s.parse::<i64>().unwrap(),
        _ => unreachable!()
    };

Ident: String = "IDENT"
    => match <> {
        token::Token::Ident(s) => s,
        _ => unreachable!()
    };


extern {
    type Location = location::Location;
    type Error = lexer::UnexpectedCharError;

    enum token::Token {
        "," => token::Token::Comma,
        ";" => token::Token::Semi,
        "{" => token::Token::BraceOpen,
        "}" => token::Token::BraceClose,
        "(" => token::Token::ParenOpen,
        ")" => token::Token::ParenClose,
        "[" => token::Token::BracketOpen,
        "]" => token::Token::BracketClose,
        "=" => token::Token::Equals,
        ":" => token::Token::Colon,
        "+" => token::Token::Plus,
        "-" => token::Token::Minus,
        "*" => token::Token::Star,
        "/" => token::Token::Slash,
        "%" => token::Token::Percent,
        "~" => token::Token::Tilde,
        "!" => token::Token::Exclamation,
        "&" => token::Token::Ampersand,
        "->" => token::Token::Arrow,
        "while" => token::Token::While,
        "if" => token::Token::If,
        "else" => token::Token::Else,
        "return" => token::Token::Return,
        "func" => token::Token::Func,
        "struct" => token::Token::Struct,
        "as" => token::Token::As,
        "u8" => token::Token::U8,
        "void" => token::Token::Void,
        "INTEGER" => token::Token::Integer(_),
        "IDENT" => token::Token::Ident(_),
    }
}